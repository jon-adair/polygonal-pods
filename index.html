<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Isometric Room with Draggable Shapes - Three.js</title>
<style>
  body { margin: 0; }
  #threejs-canvas {
    position: absolute;
    left: 280px;
    top: 0;
    width: calc(100vw - 280px);
    height: 100vh;
    display: block;
    z-index: 1;
  }
  #controls {
    position: fixed;
    top: 0;
    left: 0;
    width: 280px;
    height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: 10px;
    z-index: 10;
    background: rgba(255,255,255,0.95);
    padding: 24px 24px 12px 24px;
    border-top-right-radius: 12px;
    border-bottom-right-radius: 12px;
    box-shadow: 2px 0 12px rgba(0,0,0,0.08);
  }
	button {
		margin: 0 0 8px 0;
		padding: 10px 0;
		font-size: 1rem;
		border-radius: 6px;
		border: 1px solid #ccc;
		background: #f7f7f7;
		cursor: pointer;
		transition: background 0.2s;
	}
	button:hover {
		background: #e0e0e0;
	}
</style>
</head>
<body>
<div id="controls">
  <button id="addModuleBtn">Add Module</button>
  <button id="removeModuleBtn">Remove Module</button>
  <button id="newLayoutBtn">New Layout</button>
  <div id="moduleSelect" style="display:none; flex-direction:column; gap:6px;"></div>
  <button id="saveBtn">Save Positions</button>
  <button id="restoreBtn">Restore Positions</button>
  <div id="layoutSelect" style="display:none; flex-direction:column; gap:6px;"></div>
  <div id="infoPanel" style="margin-top:24px; padding:12px; background:#f7f7f7; border-radius:8px; border:1px solid #ddd; font-size:1rem;">
  <div id="wcsStatus">WCS module: <span id="wcsVal">NO</span></div>
  <div id="berthStatus">berth module: <span id="berthVal">NO</span></div>
  <div id="sepStatus" style="margin-top:8px;">WCS / berth separation: <span id="sepVal">-</span></div>
  <div id="camAngles" style="margin-top:16px; font-size:0.95rem; color:#555;">Camera angles: <span id="camTheta">-</span>°, <span id="camPhi">-</span>°</div>
  </div>
</div>
<div id="moduleTooltip" style="position:fixed; left:0; top:0; pointer-events:none; background:#fffbe7; color:#333; border:1px solid #ccc; border-radius:6px; padding:4px 10px; font-size:1rem; box-shadow:0 2px 8px rgba(0,0,0,0.08); display:none; z-index:1000"></div>
</div>
<script type="module">
// Shapes array must be top-level for global access
const shapes = [];

// Scene, camera, renderer (must be initialized before any usage)
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xececec);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(3.5, 3.5, 3.5);
camera.lookAt(0, -0.8, 0);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth - 280, window.innerHeight);
renderer.domElement.id = 'threejs-canvas';
document.body.appendChild(renderer.domElement);

function updateInfoPanel() {
  // Update camera angles
  const camTheta = document.getElementById('camTheta');
  const camPhi = document.getElementById('camPhi');
  if (camTheta && camPhi) {
    camTheta.textContent = (orbitTheta * 180 / Math.PI).toFixed(1);
    camPhi.textContent = (orbitPhi * 180 / Math.PI).toFixed(1);
  }
  const wcsVal = document.getElementById('wcsVal');
  const berthVal = document.getElementById('berthVal');
  const sepVal = document.getElementById('sepVal');
  let wcs = null, berth = null;
  for (const shape of shapes) {
    if (shape.moduleData && shape.moduleData.name === 'WCS') wcs = shape;
    if (shape.moduleData && shape.moduleData.name === 'berth') berth = shape;
  }
  if (wcs) {
    wcsVal.textContent = 'YES';
    wcsVal.style.color = '#228B22';
    wcsVal.style.fontWeight = 'bold';
  } else {
    wcsVal.textContent = 'NO';
    wcsVal.style.color = '#c00';
    wcsVal.style.fontWeight = 'bold';
  }
  if (berth) {
    berthVal.textContent = 'YES';
    berthVal.style.color = '#228B22';
    berthVal.style.fontWeight = 'bold';
  } else {
    berthVal.textContent = 'NO';
    berthVal.style.color = '#c00';
    berthVal.style.fontWeight = 'bold';
  }
  if (wcs && berth) {
    const dist = wcs.position.distanceTo(berth.position);
    sepVal.textContent = dist.toFixed(2);
    if (dist < 2.5) {
      sepVal.style.color = '#c00';
      sepVal.style.fontWeight = 'bold';
    } else {
      sepVal.style.color = '';
      sepVal.style.fontWeight = '';
    }
  } else {
    sepVal.textContent = '-';
    sepVal.style.color = '';
    sepVal.style.fontWeight = '';
  }
}

// Call updateInfoPanel after any change to shapes
setInterval(updateInfoPanel, 500);
const tooltip = document.getElementById('moduleTooltip');
// ...existing code...
// Scene, camera, renderer
// ...existing code...
scene.background = new THREE.Color(0xececec);
// ...camera already declared above...

// Camera orbit controls (Ctrl+drag) - must be after camera is declared
let isOrbiting = false;
let lastOrbitX = 0, lastOrbitY = 0;
let orbitTheta = Math.atan2(camera.position.z, camera.position.x);
let orbitPhi = Math.acos(camera.position.y / camera.position.length());
const orbitRadius = camera.position.length();
const orbitTarget = new THREE.Vector3(0, -0.8, 0);

renderer.domElement.addEventListener('pointerdown', (e) => {
  if (e.shiftKey) {
    isOrbiting = true;
    lastOrbitX = e.clientX;
    lastOrbitY = e.clientY;
    renderer.domElement.style.cursor = 'grab';
  }
});
renderer.domElement.addEventListener('pointerup', () => {
  isOrbiting = false;
  renderer.domElement.style.cursor = '';
});
renderer.domElement.addEventListener('pointerleave', () => {
  isOrbiting = false;
  renderer.domElement.style.cursor = '';
});
renderer.domElement.addEventListener('pointermove', (e) => {
  if (isOrbiting) {
    const dx = e.clientX - lastOrbitX;
    const dy = e.clientY - lastOrbitY;
    lastOrbitX = e.clientX;
    lastOrbitY = e.clientY;
    orbitTheta -= dx * 0.01;
  orbitPhi -= dy * 0.01;
  // Clamp phi so camera can't go below the floor (0 = horizontal) or above 80 degrees
  const maxPhi = Math.PI * 80 / 180;
  orbitPhi = Math.max(0, Math.min(maxPhi, orbitPhi));
    // Spherical to Cartesian
    const x = orbitRadius * Math.sin(orbitPhi) * Math.cos(orbitTheta);
    const y = orbitRadius * Math.cos(orbitPhi);
    const z = orbitRadius * Math.sin(orbitPhi) * Math.sin(orbitTheta);
    camera.position.set(x, y, z).add(orbitTarget);
    camera.lookAt(orbitTarget);
  }
});

window.addEventListener('resize', () => {
  renderer.setSize(window.innerWidth - 280, window.innerHeight);
  camera.aspect = (window.innerWidth - 280) / window.innerHeight;
  camera.updateProjectionMatrix();
});

// Tooltip event handler (immediately after renderer creation)
renderer.domElement.addEventListener('mousemove', (event) => {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(shapes.flatMap(obj => obj.type === 'Group' ? obj.children : [obj]));
  if (intersects.length > 0) {
    const hoveredShape = shapes.find(obj => obj === intersects[0].object || (obj.type === 'Group' && obj.children.includes(intersects[0].object)));
    if (hoveredShape && hoveredShape.moduleData && hoveredShape.moduleData.name) {
      let dirty = hoveredShape.moduleData.dirty;
      let dirtyText = (typeof dirty !== 'undefined') ? `\n(Dirty: ${dirty})` : '';
      tooltip.textContent = hoveredShape.moduleData.name + dirtyText;
      tooltip.style.display = 'block';
      tooltip.style.left = (event.clientX + 10) + 'px';
      tooltip.style.top = (event.clientY + 18) + 'px';
    } else {
      tooltip.style.display = 'none';
    }
  } else {
    tooltip.style.display = 'none';
  }
});
// --- Collision Detection ---
function getBounding(shape) {
      if (shape.type === 'Group') {
        // Capsule: bounding sphere
        // Approximate as a sphere centered at group.position, radius = capsule height/2
        // Actually, capsule: radius is max of cylinder radius and half cylinder height
        // But for simplicity, use bounding sphere with radius = cylinderHeight/2 + radius
        const cyl = shape.children[0];
        const radius = cyl.geometry.parameters.radiusTop;
        const height = cyl.geometry.parameters.height;
        return {
          type: 'sphere',
          center: shape.position,
          radius: height / 2 + radius
        };
      } else {
        // Cube: bounding box
        const geo = shape.geometry.parameters;
        return {
          type: 'box',
          center: shape.position,
          size: [geo.width, geo.height, geo.depth]
        };
      }
    }

function isColliding(a, b, newPosA = null) {
      // a and b are shapes; newPosA is optional position for a
      const ba = getBounding(a);
      const bb = getBounding(b);
      // Use newPosA if provided
      const ca = newPosA || ba.center;
      const cb = bb.center;
      if (ba.type === 'box' && bb.type === 'box') {
        // AABB collision
        const sa = ba.size, sb = bb.size;
        return Math.abs(ca.x - cb.x) <= (sa[0] + sb[0]) / 2 &&
               Math.abs(ca.y - cb.y) <= (sa[1] + sb[1]) / 2 &&
               Math.abs(ca.z - cb.z) <= (sa[2] + sb[2]) / 2;
      } else if (ba.type === 'sphere' && bb.type === 'sphere') {
        // Sphere-sphere
        const dist = ca.distanceTo(cb);
        return dist < (ba.radius + bb.radius);
      } else {
        // Box-sphere
        let box, sphere, boxCenter, sphereCenter, boxSize, sphereRadius;
        if (ba.type === 'box') {
          box = ba; boxCenter = ca; boxSize = ba.size;
          sphere = bb; sphereCenter = cb; sphereRadius = bb.radius;
        } else {
          box = bb; boxCenter = cb; boxSize = bb.size;
          sphere = ba; sphereCenter = ca; sphereRadius = ba.radius;
        }
        // Clamp sphere center to box
        const dx = Math.max(boxCenter.x - boxSize[0]/2, Math.min(sphereCenter.x, boxCenter.x + boxSize[0]/2));
        const dy = Math.max(boxCenter.y - boxSize[1]/2, Math.min(sphereCenter.y, boxCenter.y + boxSize[1]/2));
        const dz = Math.max(boxCenter.z - boxSize[2]/2, Math.min(sphereCenter.z, boxCenter.z + boxSize[2]/2));
        const closest = new THREE.Vector3(dx, dy, dz);
        return closest.distanceTo(sphereCenter) < sphereRadius;
      }
    }

import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';
// ...existing code...

// Floor (circular)
  const floorRadius = 4;
  const floorGeometry = new THREE.CylinderGeometry(floorRadius, floorRadius, 0.2, 64);
  // Create a subtle grid texture using canvas
  const gridCanvas = document.createElement('canvas');
  gridCanvas.width = gridCanvas.height = 256;
  const ctx = gridCanvas.getContext('2d');
  ctx.fillStyle = '#f3e7d7';
  ctx.fillRect(0, 0, 256, 256);
  ctx.strokeStyle = '#d2c2b2';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 256; i += 32) {
    ctx.beginPath();
    ctx.moveTo(i, 0); ctx.lineTo(i, 256);
    ctx.moveTo(0, i); ctx.lineTo(256, i);
    ctx.stroke();
  }
  const gridTexture = new THREE.CanvasTexture(gridCanvas);
  gridTexture.wrapS = gridTexture.wrapT = THREE.RepeatWrapping;
  gridTexture.repeat.set(2, 2);
  const floorMaterial = new THREE.MeshLambertMaterial({ color: 0xbfae9e, map: gridTexture });
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.position.y = -0.1;
  scene.add(floor);

// (Walls removed)

// Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
    directionalLight.position.set(5, 10, 7.5);
    scene.add(directionalLight);

// Three cubes, different sizes and colors

// Raycaster and mouse
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let selectedShape = null;
    let offset = new THREE.Vector3();
    let selectedY = 0;
    let selectedEdges = null;
    let isDragging = false;

function getIntersects(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      // For capsule, use its children for raycast
      return raycaster.intersectObjects(shapes.flatMap(obj => obj.type === 'Group' ? obj.children : [obj]));
    }

renderer.domElement.addEventListener('pointerdown', (event) => {
  isDragging = false;
  const intersects = getIntersects(event);
  if (intersects.length > 0) {
    // Find parent shape
    const clickedShape = shapes.find(obj => obj === intersects[0].object || (obj.type === 'Group' && obj.children.includes(intersects[0].object)));
    // Deselect if already selected
    if (clickedShape === selectedShape) {
      if (selectedEdges) {
        scene.remove(selectedEdges);
        selectedEdges = null;
      }
      selectedShape = null;
      return;
    }
    // Selection logic
    if (selectedEdges) {
      scene.remove(selectedEdges);
      selectedEdges = null;
    }
    if (clickedShape) {
      selectedShape = clickedShape;
      // Highlight edges if it's a cube
      if (clickedShape.type === 'Mesh' && clickedShape.geometry.type === 'BoxGeometry') {
        selectedEdges = new THREE.LineSegments(
          new THREE.EdgesGeometry(clickedShape.geometry),
          new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 })
        );
        selectedEdges.position.copy(clickedShape.position);
        scene.add(selectedEdges);
      }
    }
    // Find intersection point with floor for drag
    raycaster.setFromCamera(mouse, camera);
    const floorIntersect = raycaster.intersectObject(floor);
    if (floorIntersect.length > 0) {
      offset.copy(clickedShape.position).sub(floorIntersect[0].point);
      selectedY = clickedShape.position.y;
      isDragging = true;
    }
  } else {
    // Deselect if click on empty space
    if (selectedEdges) {
      scene.remove(selectedEdges);
      selectedEdges = null;
    }
    selectedShape = null;
  }
});

renderer.domElement.addEventListener('pointermove', (event) => {
    if (!selectedShape || !isDragging) return;
    raycaster.setFromCamera(mouse, camera);
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    const floorIntersect = raycaster.intersectObject(floor);
    if (floorIntersect.length > 0) {
        let newPos = floorIntersect[0].point.clone().add(offset);
        // Clamp to floor bounds
        newPos.x = Math.max(-3.5, Math.min(3.5, newPos.x));
        newPos.z = Math.max(-3.5, Math.min(3.5, newPos.z));
        newPos.y = selectedY;
        // Check collision with other shapes
        let collision = false;
        for (const other of shapes) {
            if (other !== selectedShape && isColliding(selectedShape, other, newPos)) {
                collision = true;
                break;
            }
        }
        if (!collision) {
            selectedShape.position.copy(newPos);
            if (selectedEdges) selectedEdges.position.copy(newPos);
        }
    }
});

renderer.domElement.addEventListener('pointerup', () => {
  isDragging = false;
});
// Remove Module button logic
document.getElementById('removeModuleBtn').onclick = () => {
  if (selectedShape) {
    // Remove highlight
    if (selectedEdges) {
      scene.remove(selectedEdges);
      selectedEdges = null;
    }
    // Remove from scene and shapes array
    if (selectedShape.parent) selectedShape.parent.remove(selectedShape);
    const idx = shapes.indexOf(selectedShape);
    if (idx !== -1) shapes.splice(idx, 1);
    selectedShape = null;
  }
};

// Save/Restore logic
let currentLayoutName = null;
let savedPositions = null;

document.getElementById('newLayoutBtn').onclick = () => {
  const name = prompt('Enter a name for the new layout:');
  if (!name) return;
  currentLayoutName = name;
  // Remove all shapes from scene
  while (shapes.length) {
    const removed = shapes.pop();
    if (removed.parent) removed.parent.remove(removed);
  }
  // New layout starts blank (just the floor)
};

document.getElementById('saveBtn').onclick = () => {
  if (!currentLayoutName) {
    alert('Please create or select a layout first.');
    return;
  }
  const positions = shapes.map(shape => {
    const entry = shape.moduleData || {};
    return {
      ...entry,
      x: shape.position.x,
      y: shape.position.y,
      z: shape.position.z
    };
  });
  fetch('/api/layouts/save', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name: currentLayoutName, positions })
  })
    .then(res => res.json())
    .then(data => {
      let msg = document.createElement('div');
      msg.textContent = data.success ? 'Layout saved!' : 'Save failed.';
      msg.style.position = 'fixed';
      msg.style.top = '24px';
      msg.style.left = '50%';
      msg.style.transform = 'translateX(-50%)';
      msg.style.background = '#fffbe7';
      msg.style.color = '#333';
      msg.style.border = '1px solid #ccc';
      msg.style.borderRadius = '8px';
      msg.style.padding = '10px 24px';
      msg.style.fontSize = '1.1rem';
      msg.style.zIndex = '2000';
      document.body.appendChild(msg);
      setTimeout(() => { msg.remove(); }, 1000);
    })
    .catch(() => {
      let msg = document.createElement('div');
      msg.textContent = 'Save failed.';
      msg.style.position = 'fixed';
      msg.style.top = '24px';
      msg.style.left = '50%';
      msg.style.transform = 'translateX(-50%)';
      msg.style.background = '#fffbe7';
      msg.style.color = '#333';
      msg.style.border = '1px solid #ccc';
      msg.style.borderRadius = '8px';
      msg.style.padding = '10px 24px';
      msg.style.fontSize = '1.1rem';
      msg.style.zIndex = '2000';
      document.body.appendChild(msg);
      setTimeout(() => { msg.remove(); }, 1000);
    });
};

document.getElementById('restoreBtn').onclick = () => {
 const layoutSelect = document.getElementById('layoutSelect');
 layoutSelect.innerHTML = '';
 layoutSelect.style.display = 'flex';
 fetch('/api/layouts')
   .then(res => res.json())
   .then(layouts => {
     const names = Object.keys(layouts);
     if (names.length === 0) {
       alert('No saved layouts found.');
       layoutSelect.style.display = 'none';
       return;
     }
     names.forEach(name => {
       const btn = document.createElement('button');
       btn.textContent = name;
       btn.onclick = () => {
         layoutSelect.style.display = 'none';
         currentLayoutName = name;
         const positions = layouts[name];
         // Remove all cubes
         while (shapes.length > positions.length) {
           const removed = shapes.pop();
           if (removed.parent) removed.parent.remove(removed);
         }
         shapes.forEach((shape, i) => {
           shape.position.set(positions[i].x, positions[i].y, positions[i].z);
           if (positions[i].color && shape.material) {
             shape.material.color.set(positions[i].color);
           }
           // Attach module data for future saves
           shape.moduleData = {};
           for (const key in positions[i]) {
             if (!['x','y','z'].includes(key)) shape.moduleData[key] = positions[i][key];
           }
         });
         // If more positions than shapes, add cubes
         for (let i = shapes.length; i < positions.length; i++) {
           const mod = positions[i];
           const cube = new THREE.Mesh(
             new THREE.BoxGeometry(
               mod.packedsize?.width || 1,
               mod.packedsize?.height || 1,
               mod.packedsize?.depth || 1
             ),
             new THREE.MeshLambertMaterial({ color: mod.color || 0x888888, transparent: true, opacity: 0.8 })
           );
           cube.position.set(mod.x, mod.y, mod.z);
           cube.moduleData = {};
           for (const key in mod) {
             if (!['x','y','z'].includes(key)) cube.moduleData[key] = mod[key];
           }
           shapes.push(cube);
           scene.add(cube);
         }
       };
       layoutSelect.appendChild(btn);
     });
   })
   .catch(() => {
     alert('Failed to load layouts.');
     layoutSelect.style.display = 'none';
   });
};

// Add Module button logic
document.getElementById('addModuleBtn').onclick = () => {
  // Load modules.json and present clickable buttons for selection
  const moduleSelect = document.getElementById('moduleSelect');
  moduleSelect.innerHTML = '';
  moduleSelect.style.display = 'flex';
  fetch('modules.json?v=' + Date.now())
    .then(res => res.json())
    .then(modules => {
      if (!Array.isArray(modules) || modules.length === 0) {
        alert('No modules found.');
        moduleSelect.style.display = 'none';
        return;
      }
      modules.forEach((mod, idx) => {
        const btn = document.createElement('button');
        btn.textContent = mod.name;
        btn.style.background = mod.color || '#eee';
        btn.onclick = () => {
          console.log('Selected module:', mod);
          moduleSelect.style.display = 'none';
          // Use packedsize and color
          const w = (mod.packedsize?.width);
          const h = (mod.packedsize?.height);
          const d = (mod.packedsize?.depth);
          console.log(w,h,d);
          const color = mod.color || '#888888';
          const cube = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            new THREE.MeshLambertMaterial({ color, transparent: true, opacity: 0.8 })
          );
          cube.moduleData = { ...mod };
          let placed = false;
          let attempts = 0;
          while (!placed && attempts < 50) {
            const x = Math.random() * (7 - w) - (3.5 - w/2);
            const z = Math.random() * (7 - d) - (3.5 - d/2);
            const y = h / 2;
            cube.position.set(x, y, z);
            console.log(`Trying position: ${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)}`);
            let collision = false;
            for (const other of shapes) {
              if (isColliding(cube, other)) {
                collision = true;
                break;
              }
            }
            if (!collision) placed = true;
            attempts++;
          }
          if (placed) {
            shapes.push(cube);
            scene.add(cube);
          } else {
            alert('Could not place new module without collision.');
          }
        };
        moduleSelect.appendChild(btn);
      });
    })
    .catch(() => {
      alert('Failed to load modules.json');
      moduleSelect.style.display = 'none';
    });
};

// Render loop
function animate() {
	requestAnimationFrame(animate);
	renderer.render(scene, camera);
}
animate();
  </script>
</body>
</html>
