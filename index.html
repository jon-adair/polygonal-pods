<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Isometric Room with Draggable Shapes - Three.js</title>
<style>
  body { margin: 0; }
  #threejs-canvas {
    position: absolute;
    left: 280px;
    top: 0;
    width: calc(100vw - 280px);
    height: 100vh;
    display: block;
    z-index: 1;
  }
  #controls {
    position: fixed;
    top: 0;
    left: 0;
    width: 280px;
    height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: 10px;
    z-index: 10;
    background: rgba(255,255,255,0.95);
    padding: 24px 24px 12px 24px;
    border-top-right-radius: 12px;
    border-bottom-right-radius: 12px;
    box-shadow: 2px 0 12px rgba(0,0,0,0.08);
  }
  .floorBtn.selected {
    background: #2266cc;
    color: #fff;
    font-weight: bold;
    border: 2px solid #2266cc;
  }
	button {
		margin: 0 0 8px 0;
		padding: 10px 0;
		font-size: 1rem;
		border-radius: 6px;
		border: 1px solid #ccc;
		background: #f7f7f7;
		cursor: pointer;
		transition: background 0.2s;
	}
	button:hover {
		background: #e0e0e0;
	}
</style>
</head>
<body>
<div id="controls">
  <div style="display:flex; flex-direction:row; gap:8px; margin-bottom:10px; width:100%;">
    <button class="floorBtn" id="floorBtn1" style="flex:1 1 0;">1</button>
    <button class="floorBtn" id="floorBtn2" style="flex:1 1 0;">2</button>
    <button class="floorBtn" id="floorBtn3" style="flex:1 1 0;">3</button>
  </div>
  <button id="addModuleBtn">Add Module</button>
  <button id="removeModuleBtn">Remove Module</button>
  <button id="newLayoutBtn">New Layout</button>
  <div id="moduleSelect" style="display:none; flex-direction:column; gap:6px;"></div>
  <button id="saveBtn">Save Positions</button>
  <button id="restoreBtn">Restore Positions</button>
  <div id="layoutSelect" style="display:none; flex-direction:column; gap:6px;"></div>
  <div id="infoPanel" style="margin-top:24px; padding:12px; background:#f7f7f7; border-radius:8px; border:1px solid #ddd; font-size:1rem;">
  <div id="wcsStatus">WCS module: <span id="wcsVal">NO</span></div>
  <div id="berthStatus">berth module: <span id="berthVal">NO</span></div>
  <div id="sepStatus" style="margin-top:8px;">WCS / berth separation: <span id="sepVal">-</span></div>
  <div id="camAngles" style="margin-top:16px; font-size:0.95rem; color:#555;">Camera angles: <span id="camTheta">-</span>°, <span id="camPhi">-</span>°</div>
  </div>
</div>
<div id="moduleTooltip" style="position:fixed; left:0; top:0; pointer-events:none; background:#fffbe7; color:#333; border:1px solid #ccc; border-radius:6px; padding:4px 10px; font-size:1rem; box-shadow:0 2px 8px rgba(0,0,0,0.08); display:none; z-index:1000"></div>
</div>
<script type="module">
// Multi-floor support
const NUM_FLOORS = 3;
let currentFloor = 0;
const floors = Array.from({length: NUM_FLOORS}, (_, i) => ({
  shapes: [],
  floorMesh: null
}));

// Scene, camera, renderer (must be initialized before any usage)
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xececec);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(3.5, 3.5, 3.5);
camera.lookAt(0, -0.8, 0);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth - 280, window.innerHeight);
renderer.domElement.id = 'threejs-canvas';
document.body.appendChild(renderer.domElement);

function updateInfoPanel() {
  // Update camera angles
  const camTheta = document.getElementById('camTheta');
  const camPhi = document.getElementById('camPhi');
  if (camTheta && camPhi) {
    camTheta.textContent = (orbitTheta * 180 / Math.PI).toFixed(1);
    camPhi.textContent = (orbitPhi * 180 / Math.PI).toFixed(1);
  }
  const wcsVal = document.getElementById('wcsVal');
  const berthVal = document.getElementById('berthVal');
  const sepVal = document.getElementById('sepVal');
  let wcs = null, berth = null;
  for (const shape of floors[currentFloor].shapes) {
    if (shape.moduleData && shape.moduleData.name === 'WCS') wcs = shape;
    if (shape.moduleData && shape.moduleData.name === 'berth') berth = shape;
  }
  if (wcs) {
    wcsVal.textContent = 'YES';
    wcsVal.style.color = '#228B22';
    wcsVal.style.fontWeight = 'bold';
  } else {
    wcsVal.textContent = 'NO';
    wcsVal.style.color = '#c00';
    wcsVal.style.fontWeight = 'bold';
  }
  if (berth) {
    berthVal.textContent = 'YES';
    berthVal.style.color = '#228B22';
    berthVal.style.fontWeight = 'bold';
  } else {
    berthVal.textContent = 'NO';
    berthVal.style.color = '#c00';
    berthVal.style.fontWeight = 'bold';
  }
  if (wcs && berth) {
    // Compute center point of each pie segment
    function getPieCenter(shape) {
      if (shape.type === 'PieSegment') {
        const angle = (shape.userData.startAngle + shape.userData.endAngle) / 2;
        const innerRadius = shape.userData.innerRadius || 0;
        const outerRadius = shape.userData.outerRadius || 0;
        const radius = (innerRadius + outerRadius) / 2;
        return new THREE.Vector3(
          radius * Math.cos(angle),
          0,
          radius * Math.sin(angle)
        );
      } else {
        return shape.position;
      }
    }
    const wcsCenter = getPieCenter(wcs);
    const berthCenter = getPieCenter(berth);
    const dist = wcsCenter.distanceTo(berthCenter);
    sepVal.textContent = dist.toFixed(2);
    if (dist < 2.5) {
      sepVal.style.color = '#c00';
      sepVal.style.fontWeight = 'bold';
    } else {
      sepVal.style.color = '';
      sepVal.style.fontWeight = '';
    }
  } else {
    sepVal.textContent = '-';
    sepVal.style.color = '';
    sepVal.style.fontWeight = '';
  }
}

// Call updateInfoPanel after any change to shapes
setInterval(updateInfoPanel, 500);
const tooltip = document.getElementById('moduleTooltip');
// ...existing code...
// Scene, camera, renderer
// ...existing code...
scene.background = new THREE.Color(0xececec);
// ...camera already declared above...

// Camera orbit controls (Ctrl+drag) - must be after camera is declared
let isOrbiting = false;
let lastOrbitX = 0, lastOrbitY = 0;
let orbitTheta = Math.atan2(camera.position.z, camera.position.x);
let orbitPhi = Math.acos(camera.position.y / camera.position.length());
const orbitRadius = camera.position.length();
const orbitTarget = new THREE.Vector3(0, -0.8, 0);

renderer.domElement.addEventListener('pointerdown', (e) => {
  if (e.shiftKey) {
    isOrbiting = true;
    lastOrbitX = e.clientX;
    lastOrbitY = e.clientY;
    renderer.domElement.style.cursor = 'grab';
  }
});
renderer.domElement.addEventListener('pointerup', () => {
  isOrbiting = false;
  renderer.domElement.style.cursor = '';
});
renderer.domElement.addEventListener('pointerleave', () => {
  isOrbiting = false;
  renderer.domElement.style.cursor = '';
});
renderer.domElement.addEventListener('pointermove', (e) => {
  if (isOrbiting) {
    const dx = e.clientX - lastOrbitX;
    const dy = e.clientY - lastOrbitY;
    lastOrbitX = e.clientX;
    lastOrbitY = e.clientY;
    orbitTheta -= dx * 0.01;
  orbitPhi -= dy * 0.01;
  // Clamp phi so camera can't go below the floor (0 = horizontal) or above 80 degrees
  const maxPhi = Math.PI * 80 / 180;
  orbitPhi = Math.max(0, Math.min(maxPhi, orbitPhi));
    // Spherical to Cartesian
    const x = orbitRadius * Math.sin(orbitPhi) * Math.cos(orbitTheta);
    const y = orbitRadius * Math.cos(orbitPhi);
    const z = orbitRadius * Math.sin(orbitPhi) * Math.sin(orbitTheta);
    camera.position.set(x, y, z).add(orbitTarget);
    camera.lookAt(orbitTarget);
  }
});

window.addEventListener('resize', () => {
  renderer.setSize(window.innerWidth - 280, window.innerHeight);
  camera.aspect = (window.innerWidth - 280) / window.innerHeight;
  camera.updateProjectionMatrix();
});

// Tooltip event handler (immediately after renderer creation)
renderer.domElement.addEventListener('mousemove', (event) => {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(floors[currentFloor].shapes.flatMap(obj => obj.type === 'Group' ? obj.children : [obj]));
  if (intersects.length > 0) {
  const hoveredShape = floors[currentFloor].shapes.find(obj => obj === intersects[0].object || (obj.type === 'Group' && obj.children.includes(intersects[0].object)));
    if (hoveredShape && hoveredShape.moduleData && hoveredShape.moduleData.name) {
      let dirty = hoveredShape.moduleData.dirty;
      let dirtyText = (typeof dirty !== 'undefined') ? `\n(Dirty: ${dirty})` : '';
      tooltip.textContent = hoveredShape.moduleData.name + dirtyText;
      tooltip.style.display = 'block';
      tooltip.style.left = (event.clientX + 10) + 'px';
      tooltip.style.top = (event.clientY + 18) + 'px';
    } else {
      tooltip.style.display = 'none';
    }
  } else {
    tooltip.style.display = 'none';
  }
});
// --- Collision Detection ---
function getBounding(shape) {
      if (shape.type === 'Group') {
        // Capsule: bounding sphere
        // Approximate as a sphere centered at group.position, radius = capsule height/2
        // Actually, capsule: radius is max of cylinder radius and half cylinder height
        // But for simplicity, use bounding sphere with radius = cylinderHeight/2 + radius
        const cyl = shape.children[0];
        const radius = cyl.geometry.parameters.radiusTop;
        const height = cyl.geometry.parameters.height;
        return {
          type: 'sphere',
          center: shape.position,
          radius: height / 2 + radius
        };
      } else if (shape.type === 'CenterCylinder') {
        // Center cylinder: bounding cylinder
        const geo = shape.geometry.parameters;
        return {
          type: 'cylinder',
          center: shape.position,
          radius: geo.radiusTop,
          height: geo.height
        };
      } else {
        // Cube: bounding box
        const geo = shape.geometry.parameters;
        return {
          type: 'box',
          center: shape.position,
          size: [geo.width, geo.height, geo.depth]
        };
      }
    }

function isColliding(a, b, newPosA = null) {
      // a and b are shapes; newPosA is optional position for a
      const ba = getBounding(a);
      const bb = getBounding(b);
      // Use newPosA if provided
      const ca = newPosA || ba.center;
      const cb = bb.center;
      if (ba.type === 'box' && bb.type === 'box') {
        // AABB collision
        const sa = ba.size, sb = bb.size;
        return Math.abs(ca.x - cb.x) <= (sa[0] + sb[0]) / 2 &&
               Math.abs(ca.y - cb.y) <= (sa[1] + sb[1]) / 2 &&
               Math.abs(ca.z - cb.z) <= (sa[2] + sb[2]) / 2;
      } else if (ba.type === 'sphere' && bb.type === 'sphere') {
        // Sphere-sphere
        const dist = ca.distanceTo(cb);
        return dist < (ba.radius + bb.radius);
      } else if ((ba.type === 'cylinder' && bb.type === 'box') || (ba.type === 'box' && bb.type === 'cylinder')) {
        // Cylinder-box collision: treat cylinder as vertical, check box overlap in xz and y
        let cyl, box, cylCenter, boxCenter, boxSize;
        if (ba.type === 'cylinder') {
          cyl = ba; cylCenter = ca;
          box = bb; boxCenter = cb; boxSize = bb.size;
        } else {
    const intersects = raycaster.intersectObjects(floors[currentFloor].shapes.flatMap(obj => obj.type === 'Group' ? obj.children : [obj]));
          box = ba; boxCenter = ca; boxSize = ba.size;
        }
        // Check y overlap
        const cylMinY = cylCenter.y - cyl.height/2;
        const cylMaxY = cylCenter.y + cyl.height/2;
        const boxMinY = boxCenter.y - boxSize[1]/2;
        const boxMaxY = boxCenter.y + boxSize[1]/2;
        const yOverlap = Math.max(cylMinY, boxMinY) <= Math.min(cylMaxY, boxMaxY);
        // Check xz overlap (circle-box)
        const dx = Math.max(boxCenter.x - boxSize[0]/2, Math.min(cylCenter.x, boxCenter.x + boxSize[0]/2));
        const dz = Math.max(boxCenter.z - boxSize[2]/2, Math.min(cylCenter.z, boxCenter.z + boxSize[2]/2));
        const distXZ = Math.sqrt((dx - cylCenter.x)**2 + (dz - cylCenter.z)**2);
        const xzOverlap = distXZ < cyl.radius;
        return yOverlap && xzOverlap;
      } else {
        // Box-sphere
        let box, sphere, boxCenter, sphereCenter, boxSize, sphereRadius;
        if (ba.type === 'box') {
          box = ba; boxCenter = ca; boxSize = ba.size;
          sphere = bb; sphereCenter = cb; sphereRadius = bb.radius;
        } else {
          box = bb; boxCenter = cb; boxSize = ba.size;
          sphere = ba; sphereCenter = ca; sphereRadius = ba.radius;
        }
        // Clamp sphere center to box
        const dx = Math.max(boxCenter.x - boxSize[0]/2, Math.min(sphereCenter.x, boxCenter.x + boxSize[0]/2));
        const dy = Math.max(boxCenter.y - boxSize[1]/2, Math.min(sphereCenter.y, boxCenter.y + boxSize[1]/2));
        const dz = Math.max(boxCenter.z - boxSize[2]/2, Math.min(sphereCenter.z, boxCenter.z + boxSize[2]/2));
        const closest = new THREE.Vector3(dx, dy, dz);
        return closest.distanceTo(sphereCenter) < sphereRadius;
      }
    }

import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';
// ...existing code...

// Floor (circular) - create for each floor
const floorRadius = 4;
const centerHoleRadius = 0.6;
const gridCanvas = document.createElement('canvas');
gridCanvas.width = gridCanvas.height = 256;
const ctx = gridCanvas.getContext('2d');
ctx.fillStyle = '#f3e7d7';
ctx.fillRect(0, 0, 256, 256);
ctx.strokeStyle = '#d2c2b2';
ctx.lineWidth = 1;
for (let i = 0; i <= 256; i += 32) {
  ctx.beginPath();
  ctx.moveTo(i, 0); ctx.lineTo(i, 256);
  ctx.moveTo(0, i); ctx.lineTo(256, i);
  ctx.stroke();
}
const gridTexture = new THREE.CanvasTexture(gridCanvas);
gridTexture.wrapS = gridTexture.wrapT = THREE.RepeatWrapping;
gridTexture.repeat.set(2, 2);
const floorMaterial = new THREE.MeshLambertMaterial({ color: 0xbfae9e, map: gridTexture });
for (let i = 0; i < NUM_FLOORS; i++) {
  // All floors use the same cylinder geometry
  let floorGeometry = new THREE.CylinderGeometry(floorRadius, floorRadius, 0.2, 64);
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.position.y = -0.1;
  floor.visible = (i === currentFloor);
  scene.add(floor);
  floors[i].floorMesh = floor;
}

// Add center cylinder (obstacle) to each floor
for (let i = 0; i < NUM_FLOORS; i++) {
  const centerCylinderGeometry = new THREE.CylinderGeometry(0.6, 0.6, 2, 32);
  const centerCylinderMaterial = new THREE.MeshLambertMaterial({ color: 0x888888, transparent: true, opacity: 0.5 });
  const centerCylinder = new THREE.Mesh(centerCylinderGeometry, centerCylinderMaterial);
  centerCylinder.position.set(0, 0.5, 0);
  centerCylinder.type = 'CenterCylinder';
  centerCylinder.visible = (i === currentFloor);
  scene.add(centerCylinder);
  floors[i].shapes.push(centerCylinder);
}

// Add abstract blue-suited human figure inside center cylinder for each floor
for (let i = 0; i < NUM_FLOORS; i++) {
  const humanGroup = new THREE.Group();
  // Torso (blue capsule)
  const torsoGeometry = new THREE.CapsuleGeometry(0.18, 0.38, 8, 16);
  const torsoMaterial = new THREE.MeshLambertMaterial({ color: 0x2266cc });
  const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
  torso.position.set(0, 0.5, 0);
  humanGroup.add(torso);
  // Arms (blue cylinders)
  const armGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.32, 8);
  const armMaterial = new THREE.MeshLambertMaterial({ color: 0x2266cc });
  const leftArm = new THREE.Mesh(armGeometry, armMaterial);
  leftArm.position.set(-0.25, 0.45, 0);
  leftArm.rotation.z = Math.PI / 1;
  humanGroup.add(leftArm);
  const rightArm = new THREE.Mesh(armGeometry, armMaterial);
  rightArm.position.set(0.25, 0.45, 0);
  rightArm.rotation.z = -Math.PI / 1;
  humanGroup.add(rightArm);
  // Legs (blue cylinders)
  const legGeometry = new THREE.CylinderGeometry(0.07, 0.07, 0.38, 8);
  const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2266cc });
  const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
  leftLeg.position.set(-0.09, 0.12, 0);
  leftLeg.rotation.z = Math.PI / 32;
  humanGroup.add(leftLeg);
  const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
  rightLeg.position.set(0.09, 0.12, 0);
  rightLeg.rotation.z = -Math.PI / 32;
  humanGroup.add(rightLeg);
  humanGroup.visible = (i === currentFloor);
  scene.add(humanGroup);
  floors[i].shapes.push(humanGroup);
}

// Lighting
const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// Three cubes, different sizes and colors

// Raycaster and mouse
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let selectedShape = null;
let offset = new THREE.Vector3();
let selectedY = 0;
let selectedEdges = null;
let isDragging = false;

function getIntersects(event) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  // Only raycast against current floor's shapes
  return raycaster.intersectObjects(floors[currentFloor].shapes.flatMap(obj => obj.type === 'Group' ? obj.children : [obj]));
}

renderer.domElement.addEventListener('pointerdown', (event) => {
  isDragging = false;
  const intersects = getIntersects(event);
  if (intersects.length > 0) {
    // Find parent shape
  const clickedShape = floors[currentFloor].shapes.find(obj => obj === intersects[0].object || (obj.type === 'Group' && obj.children.includes(intersects[0].object)));
    // Deselect if already selected
    if (clickedShape === selectedShape) {
      if (selectedEdges) {
        scene.remove(selectedEdges);
        selectedEdges = null;
      }
      selectedShape = null;
      return;
    }
    // Selection logic
    if (selectedEdges) {
      scene.remove(selectedEdges);
      selectedEdges = null;
    }
    if (clickedShape) {
      selectedShape = clickedShape;
      // Highlight edges if it's a cube
      if (clickedShape.type === 'Mesh' && clickedShape.geometry.type === 'BoxGeometry') {
        selectedEdges = new THREE.LineSegments(
          new THREE.EdgesGeometry(clickedShape.geometry),
          new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 })
        );
        selectedEdges.position.copy(clickedShape.position);
        scene.add(selectedEdges);
      }
      // For pie segments, store initial drag angle
      if (clickedShape.type === 'PieSegment') {
        // Compute initial angle from mouse position
        const rect = renderer.domElement.getBoundingClientRect();
        const mx = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const my = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        // Project mouse to world coordinates
        const vector = new THREE.Vector3(mx, my, 0.5).unproject(camera);
        const dragAngle = Math.atan2(vector.z, vector.x);
        clickedShape.userData.dragStartAngle = dragAngle;
        clickedShape.userData.dragOrigStartAngle = clickedShape.userData.startAngle;
        clickedShape.userData.dragOrigEndAngle = clickedShape.userData.endAngle;
      }
    }
    // Find intersection point with floor for drag
  raycaster.setFromCamera(mouse, camera);
  const floorIntersect = raycaster.intersectObject(floors[currentFloor].floorMesh);
    if (floorIntersect.length > 0) {
      offset.copy(clickedShape.position).sub(floorIntersect[0].point);
      selectedY = clickedShape.position.y;
      isDragging = true;
    }
  } else {
    // Deselect if click on empty space
    if (selectedEdges) {
      scene.remove(selectedEdges);
      selectedEdges = null;
    }
    selectedShape = null;
  }
});

renderer.domElement.addEventListener('pointermove', (event) => {
    if (!selectedShape || !isDragging) return;
    if (selectedShape.type === 'PieSegment') {
      // Rotate pie segment around center based on mouse movement
      const rect = renderer.domElement.getBoundingClientRect();
      const mx = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      const my = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      // Project mouse to world coordinates
      const vector = new THREE.Vector3(mx, my, 0.5).unproject(camera);
  const dragAngle = Math.atan2(vector.z, vector.x);
  const deltaAngle = (dragAngle - selectedShape.userData.dragStartAngle) * 10;
      // Update start/end angles
      let newStart = selectedShape.userData.dragOrigStartAngle + deltaAngle;
      let newEnd = selectedShape.userData.dragOrigEndAngle + deltaAngle;
      // Clamp angles to [0, 2PI]
      newStart = ((newStart % (2*Math.PI)) + 2*Math.PI) % (2*Math.PI);
      newEnd = ((newEnd % (2*Math.PI)) + 2*Math.PI) % (2*Math.PI);
      // Check for overlap with other pie segments
      let collision = false;
  for (const other of floors[currentFloor].shapes) {
        if (other !== selectedShape && other.type === 'PieSegment') {
          const a0 = other.userData.startAngle;
          const a1 = other.userData.endAngle;
          const overlap =
            (newStart < a1 && newEnd > a0) ||
            (a0 < newEnd && a1 > newStart);
          if (overlap) {
            collision = true;
            break;
          }
        }
      }
      if (!collision) {
        // Remove old geometry
        selectedShape.geometry.dispose();
        // Recreate pie segment geometry
          const innerRadius = selectedShape.userData.innerRadius;
          const outerRadius = selectedShape.userData.outerRadius;
          const pieShape = new THREE.Shape();
          pieShape.moveTo(innerRadius * Math.cos(newStart), innerRadius * Math.sin(newStart));
          pieShape.absarc(0, 0, innerRadius, newStart, newEnd, false);
          pieShape.lineTo(outerRadius * Math.cos(newEnd), outerRadius * Math.sin(newEnd));
          pieShape.absarc(0, 0, outerRadius, newEnd, newStart, true);
          pieShape.lineTo(innerRadius * Math.cos(newStart), innerRadius * Math.sin(newStart));
          const pieHeight = selectedShape.moduleData?.packedsize?.height || 1;
          const extrudeSettings = { depth: pieHeight, bevelEnabled: false, steps: 1 };
          const geometry = new THREE.ExtrudeGeometry(pieShape, extrudeSettings);
          geometry.rotateX(-Math.PI/2);
          geometry.translate(0, 0, 0);
          selectedShape.geometry = geometry;
          selectedShape.userData.startAngle = newStart;
          selectedShape.userData.endAngle = newEnd;
      }
    } else {
      // ...existing code for cubes...
      raycaster.setFromCamera(mouse, camera);
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      const floorIntersect = raycaster.intersectObject(floor);
      if (floorIntersect.length > 0) {
          let newPos = floorIntersect[0].point.clone().add(offset);
          // Clamp to floor bounds
          newPos.x = Math.max(-3.5, Math.min(3.5, newPos.x));
          newPos.z = Math.max(-3.5, Math.min(3.5, newPos.z));
          newPos.y = selectedY;
          // Check collision with other shapes
          let collision = false;
      for (const other of floors[currentFloor].shapes) {
        if (other !== selectedShape && isColliding(selectedShape, other, newPos)) {
          collision = true;
          break;
        }
      }
          if (!collision) {
              selectedShape.position.copy(newPos);
              if (selectedEdges) selectedEdges.position.copy(newPos);
          }
      }
    }
});

renderer.domElement.addEventListener('pointerup', () => {
  isDragging = false;
});
// Remove Module button logic
document.getElementById('removeModuleBtn').onclick = () => {
  if (selectedShape) {
    if (selectedEdges) {
      scene.remove(selectedEdges);
      selectedEdges = null;
    }
    if (selectedShape.parent) selectedShape.parent.remove(selectedShape);
    const idx = floors[currentFloor].shapes.indexOf(selectedShape);
    if (idx !== -1) floors[currentFloor].shapes.splice(idx, 1);
    selectedShape = null;
  }
};

// Save/Restore logic
let currentLayoutName = null;

document.getElementById('newLayoutBtn').onclick = () => {
  const name = prompt('Enter a name for the new layout:');
  if (!name) return;
  currentLayoutName = name;
  // Remove all shapes from scene for all floors
  for (let i = 0; i < NUM_FLOORS; i++) {
    for (let j = floors[i].shapes.length - 1; j >= 0; j--) {
      const removed = floors[i].shapes[j];
      if (removed.parent) removed.parent.remove(removed);
      floors[i].shapes.splice(j, 1);
    }
    // Re-add center cylinder and human figure
    scene.add(floors[i].floorMesh);
    floors[i].floorMesh.visible = (i === currentFloor);
    // Center cylinder and human figure already in scene
  }
};

document.getElementById('saveBtn').onclick = () => {
  if (!currentLayoutName) {
    alert('Please create or select a layout first.');
    return;
  }
  // Save all floors
  const allFloors = floors.map(floor => floor.shapes.map(shape => {
    const entry = shape.moduleData || {};
    return {
      ...entry,
      x: shape.position.x,
      y: shape.position.y,
      z: shape.position.z,
      type: shape.type || null
    };
  }));
  fetch('/api/layouts/save', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name: currentLayoutName, floors: allFloors })
  })
    .then(res => res.json())
    .then(data => {
      let msg = document.createElement('div');
      msg.textContent = data.success ? 'Layout saved!' : 'Save failed.';
      msg.style.position = 'fixed';
      msg.style.top = '24px';
      msg.style.left = '50%';
      msg.style.transform = 'translateX(-50%)';
      msg.style.background = '#fffbe7';
      msg.style.color = '#333';
      msg.style.border = '1px solid #ccc';
      msg.style.borderRadius = '8px';
      msg.style.padding = '10px 24px';
      msg.style.fontSize = '1.1rem';
      msg.style.zIndex = '2000';
      document.body.appendChild(msg);
      setTimeout(() => { msg.remove(); }, 1000);
    })
    .catch(() => {
      let msg = document.createElement('div');
      msg.textContent = 'Save failed.';
      msg.style.position = 'fixed';
      msg.style.top = '24px';
      msg.style.left = '50%';
      msg.style.transform = 'translateX(-50%)';
      msg.style.background = '#fffbe7';
      msg.style.color = '#333';
      msg.style.border = '1px solid #ccc';
      msg.style.borderRadius = '8px';
      msg.style.padding = '10px 24px';
      msg.style.fontSize = '1.1rem';
      msg.style.zIndex = '2000';
      document.body.appendChild(msg);
      setTimeout(() => { msg.remove(); }, 1000);
    });
};

document.getElementById('restoreBtn').onclick = () => {
  const layoutSelect = document.getElementById('layoutSelect');
  layoutSelect.innerHTML = '';
  layoutSelect.style.display = 'flex';
  fetch('/api/layouts')
    .then(res => res.json())
    .then(layouts => {
      const names = Object.keys(layouts);
      if (names.length === 0) {
        alert('No saved layouts found.');
        layoutSelect.style.display = 'none';
        return;
      }
      names.forEach(name => {
        const btn = document.createElement('button');
        btn.textContent = name;
        btn.onclick = () => {
          layoutSelect.style.display = 'none';
          currentLayoutName = name;
          const layoutFloors = layouts[name].floors;
          for (let i = 0; i < NUM_FLOORS; i++) {
            // Remove all shapes except floorMesh, centerCylinder, humanGroup
            for (let j = floors[i].shapes.length - 1; j >= 0; j--) {
              const shape = floors[i].shapes[j];
              if (shape.type !== 'CenterCylinder' && shape.type !== undefined) {
                if (shape.parent) shape.parent.remove(shape);
                floors[i].shapes.splice(j, 1);
              }
            }
            // Restore modules for this floor
            const floorModules = layoutFloors[i] || [];
            floorModules.forEach(mod => {
              if (mod.type === 'PieSegment') {
                const color = mod.color || '#888888';
                const outerRadius = floorRadius;
                const innerRadius = Math.max(0.3, outerRadius - (mod.packedsize?.depth || 1));
                const pieShape = new THREE.Shape();
                pieShape.moveTo(innerRadius * Math.cos(mod.startAngle), innerRadius * Math.sin(mod.startAngle));
                pieShape.absarc(0, 0, innerRadius, mod.startAngle, mod.endAngle, false);
                pieShape.lineTo(outerRadius * Math.cos(mod.endAngle), outerRadius * Math.sin(mod.endAngle));
                pieShape.absarc(0, 0, outerRadius, mod.endAngle, mod.startAngle, true);
                pieShape.lineTo(innerRadius * Math.cos(mod.startAngle), innerRadius * Math.sin(mod.startAngle));
                const pieHeight = mod.packedsize?.height || 1;
                const extrudeSettings = { depth: pieHeight, bevelEnabled: false, steps: 1 };
                const geometry = new THREE.ExtrudeGeometry(pieShape, extrudeSettings);
                geometry.rotateX(-Math.PI/2);
                geometry.translate(0, 0, 0);
                const material = new THREE.MeshLambertMaterial({ color, transparent: true, opacity: 0.8 });
                const pieSegment = new THREE.Mesh(geometry, material);
                pieSegment.type = 'PieSegment';
                pieSegment.moduleData = { ...mod };
                pieSegment.userData = { startAngle: mod.startAngle, endAngle: mod.endAngle, innerRadius, outerRadius };
                pieSegment.position.set(mod.x, mod.y, mod.z);
                floors[i].shapes.push(pieSegment);
                scene.add(pieSegment);
              } else if (mod.type === null || mod.type === undefined) {
                // Ignore floorMesh, centerCylinder, humanGroup
              }
            });
          }
          // Update visibility
          for (let i = 0; i < NUM_FLOORS; i++) {
            const visible = (i === currentFloor);
            floors[i].floorMesh.visible = visible;
            floors[i].shapes.forEach(shape => { shape.visible = visible; });
          }
        };
        layoutSelect.appendChild(btn);
      });
    })
    .catch(() => {
      alert('Failed to load layouts.');
      layoutSelect.style.display = 'none';
    });
};

// Add Module button logic
document.getElementById('addModuleBtn').onclick = () => {
  // Load modules.json and present clickable buttons for selection
  const moduleSelect = document.getElementById('moduleSelect');
  moduleSelect.innerHTML = '';
  moduleSelect.style.display = 'flex';
  fetch('modules.json?v=' + Date.now())
    .then(res => res.json())
    .then(modules => {
      if (!Array.isArray(modules) || modules.length === 0) {
        alert('No modules found.');
        moduleSelect.style.display = 'none';
        return;
      }
      modules.forEach((mod, idx) => {
        const btn = document.createElement('button');
        btn.textContent = mod.name;
        btn.style.background = mod.color || '#eee';
        btn.onclick = () => {
          console.log('Selected module:', mod);
          moduleSelect.style.display = 'none';
          // Use packedsize width for pie slice angular width
          const color = mod.color || '#888888';
          const wedgeDepth = mod.packedsize?.depth || 1;
          const outerRadius = floorRadius;
          const innerRadius = Math.max(0.3, outerRadius - wedgeDepth);
          const sliceWidth = mod.packedsize?.width || 1;
          // Calculate angular width: proportional to sliceWidth
          const totalCircumference = 2 * Math.PI * ((innerRadius + floorRadius) / 2);
          const angularWidth = Math.max(0.2, sliceWidth / totalCircumference * 2 * Math.PI);
          // Find next available angle (avoid overlap)
          let startAngle = 0;
          let maxTries = 50;
          let placed = false;
          let attempts = 0;
          while (!placed && attempts < maxTries) {
            startAngle = Math.random() * 2 * Math.PI;
            let collision = false;
            for (const other of floors[currentFloor].shapes) {
              if (other.type === 'PieSegment') {
                const a0 = other.userData.startAngle;
                const a1 = other.userData.endAngle;
                const overlap =
                  (startAngle < a1 && (startAngle + angularWidth) > a0) ||
                  (a0 < (startAngle + angularWidth) && a1 > startAngle);
                if (overlap) {
                  collision = true;
                  break;
                }
              }
            }
            if (!collision) placed = true;
            attempts++;
          }
          if (placed) {
            const endAngle = startAngle + angularWidth;
            const pieShape = new THREE.Shape();
            pieShape.moveTo(innerRadius * Math.cos(startAngle), innerRadius * Math.sin(startAngle));
            pieShape.absarc(0, 0, innerRadius, startAngle, endAngle, false);
            pieShape.lineTo(outerRadius * Math.cos(endAngle), outerRadius * Math.sin(endAngle));
            pieShape.absarc(0, 0, outerRadius, endAngle, startAngle, true);
            pieShape.lineTo(innerRadius * Math.cos(startAngle), innerRadius * Math.sin(startAngle));
            const pieHeight = mod.packedsize?.height || 1;
            const extrudeSettings = { depth: pieHeight, bevelEnabled: false, steps: 1 };
            const geometry = new THREE.ExtrudeGeometry(pieShape, extrudeSettings);
            geometry.rotateX(-Math.PI/2);
            geometry.translate(0, 0, 0);
            const material = new THREE.MeshLambertMaterial({ color, transparent: true, opacity: 0.8 });
            const pieSegment = new THREE.Mesh(geometry, material);
            pieSegment.type = 'PieSegment';
            pieSegment.moduleData = { ...mod };
            pieSegment.userData = { startAngle, endAngle, innerRadius, outerRadius };
            floors[currentFloor].shapes.push(pieSegment);
            scene.add(pieSegment);
          } else {
            alert('Could not place new module without collision.');
          }
        };
        moduleSelect.appendChild(btn);
      });
    })
    .catch(() => {
      alert('Failed to load modules.json');
      moduleSelect.style.display = 'none';
    });
};

// Floor selection buttons
for (let i = 0; i < NUM_FLOORS; i++) {
  document.getElementById('floorBtn' + (i+1)).onclick = () => {
    currentFloor = i;
    for (let j = 0; j < NUM_FLOORS; j++) {
      floors[j].floorMesh.visible = (j === currentFloor);
      floors[j].shapes.forEach(shape => { shape.visible = (j === currentFloor); });
      const btn = document.getElementById('floorBtn' + (j+1));
      if (j === currentFloor) {
        btn.classList.add('selected');
      } else {
        btn.classList.remove('selected');
      }
    }
    selectedShape = null;
    if (selectedEdges) {
      scene.remove(selectedEdges);
      selectedEdges = null;
    }
  };
}
// Initial highlight
for (let i = 0; i < NUM_FLOORS; i++) {
  const btn = document.getElementById('floorBtn' + (i+1));
  if (i === currentFloor) btn.classList.add('selected');
  else btn.classList.remove('selected');
}

// Render loop
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
  </script>
</body>
</html>
